# **Flappy Bird Replica – Unity Game Development Project**  

This project is a **Unity-based replica of the classic Flappy Bird game**, developed as a personal challenge to enhance my **game development, physics simulation, and UI design skills**. I built the game from the ground up, focusing on recreating the original game’s mechanics while adding subtle improvements to **enhance performance, responsiveness, and visual appeal**.  

## **Key Features**  
✅ **Physics-based Gameplay:** Implemented smooth and realistic character movement using Unity’s **Rigidbody2D** and **Physics2D** components. The game features precise collision detection for an authentic gameplay experience.  

✅ **Procedural Pipe Generation:** Designed an **infinite scrolling system** where pipes spawn dynamically at random heights, ensuring a unique challenge every playthrough.  

✅ **Parallax Background & UI Animation:** Implemented a **layered parallax scrolling effect** to add depth to the environment, alongside smooth UI transitions for an engaging experience.  

✅ **Score System & Game Loop:** Built an intuitive score-tracking system that updates dynamically, with a **game-over state, restart mechanics, and visual feedback** for better user engagement.  

✅ **Custom Art & UI Elements:** Designed a **clean and polished UI** with custom fonts, buttons, and animations, making the game visually appealing while staying true to the original aesthetic.  

## **Technical Highlights**  
- **Developed in Unity (C#)** with efficient, reusable scripts following **Object-Oriented Programming (OOP) principles**.  
- Implemented **event-driven programming** for efficient UI updates and gameplay state transitions.  
- Used **time-based functions** to control game speed and difficulty progression dynamically.  
- Designed a lightweight **game manager system** to handle player input, collision detection, and game flow.  

## **What I Learned**  
This project strengthened my skills in **game physics, procedural content generation, UI/UX design, and performance optimization**. It also deepened my understanding of **game loops, object pooling, and event-driven programming**, which are essential for developing high-performance games.  
